//
// Created by Tianyuan Fu on 14/3/21.
//

#include "FedTree/DP/differential_privacy.h"
#include "FedTree/Tree/GBDTparam.h"
#include <numeric>
#include <random>
#include <math.h>

void DifferentialPrivacy::init(FLParam flparam) {
    GBDTParam gbdt_param = flparam.gbdt_param;
    this->lambda = gbdt_param.lambda;
    if(gbdt_param.constant_h != 0)
        this->constant_h = gbdt_param.constant_h;
    this->delta_g = 3 * this->max_gradient * this->max_gradient / this->constant_h;
    this->delta_v = this->max_gradient / (this->constant_h + this->lambda);

    this->privacy_budget = flparam.privacy_budget;
    this->privacy_budget_per_tree = this->privacy_budget / (gbdt_param.n_trees/int(1/flparam.ins_bagging_fraction));
    this->privacy_budget_leaf_nodes = this->privacy_budget_per_tree / 2.0;
    this->privacy_budget_internal_nodes = this->privacy_budget_per_tree / 2.0 / gbdt_param.depth;
}

/**
 * calculates p value based on gain value for each split point
 * @param gain - gain values of all split points in the level
 * @param prob_exponent - exponent for the probability mass; the probability mass is exp(prob_exponent[i])
 */
void DifferentialPrivacy::compute_split_point_probability(SyncArray<float_type> &gain, SyncArray<float_type> &prob_exponent) {
    auto prob_exponent_data = prob_exponent.host_data();
    auto gain_data = gain.host_data();
    for(int i = 0; i < gain.size(); i ++) {
        prob_exponent_data[i] = this->privacy_budget_internal_nodes * gain_data[i] / 2 / delta_g;
//        LOG(INFO) << "budget" << this->privacy_budget_internal_nodes;
//        LOG(INFO) << "gain" << gain_data[i];
    }
}

/**
 * exponential mechanism: randomly selects split point based on p value
 * @param prob_exponent - exponent for the probability mass; the probability mass is exp(prob_exponent[i])
 * @param gain - gain values of all split points in the level
 * @param best_idx_gain - mapping from the node index to the gain of split point; containing all the node in the level
 */
void DifferentialPrivacy::exponential_select_split_point(SyncArray<float_type> &prob_exponent, SyncArray<float_type> &gain,
                                                         SyncArray<int_float> &best_idx_gain, int n_nodes_in_level,
                                                         int n_bins) {
    // initialize randomization
    std::random_device device;
    std::mt19937 generator(device());
    std::uniform_real_distribution<> distribution(0.0, 1.0);

    auto prob_exponent_data = prob_exponent.host_data();
    auto gain_data = gain.host_data();
    auto best_idx_gain_data = best_idx_gain.host_data();

    vector<float> probability(n_bins * n_nodes_in_level);

    for(int i = 0; i < n_nodes_in_level; i ++) {
        int start = i * n_bins;
        int end = start + n_bins - 1;

        // Given the probability exponent: a, b, c, d
        // The probability[0] can be calculated by exp(a)/(exp(a)+exp(b)+exp(c)+exp(d))
        // To avoid overflow, calculation will be done in 1/(exp(a-a)+exp(b-a)+exp(c-a)+exp(d-a))
        // Probability value with respect to the bin will be stored in probability vector
        for(int j = start; j <= end; j ++) {
            float curr_exponent = prob_exponent_data[j];
            float prob_sum_denominator = 0;
            for(int k = start; k <= end; k ++) {
                prob_sum_denominator += exp(prob_exponent_data[k] - curr_exponent);
            }
            probability[j] = 1.0 / prob_sum_denominator;
        }


        float random_sample = distribution(generator);
        float partial_sum = 0;
        for(int j = start; j <= end; j ++) {
            partial_sum += probability[j];
            if(partial_sum > random_sample) {
                best_idx_gain_data[i] = thrust::make_tuple(j, gain_data[j]);
                break;
            }
        }
    }
}

/**
 * add Laplace noise to the data
 * @param node - the leaf node which noise are to be added
 */
void DifferentialPrivacy::laplace_add_noise(Tree::TreeNode &node) {
    // a Laplace(0, b) variable can be generated by the difference of two i.i.d Exponential(1/b) variables
    const float b = this->delta_v/privacy_budget_leaf_nodes;

    std::random_device device;
    std::mt19937 generator(device());
    std::exponential_distribution<float_type> distribution(1/b);

    const float_type noise = distribution(generator) - distribution(generator);
    node.base_weight += noise;
}

/**
 * add noise to gradient data and clip the value
 * @param value - gradient data
 */
void DifferentialPrivacy::add_noise_clip_gradient(float_type &value) {
    // Gradient clipping to limit sensitivity
    float_type clip_threshold = this->max_gradient;
    value = std::min(std::max(value, -clip_threshold), clip_threshold);

    // Calculate Laplace noise scale based on privacy budget and gradient sensitivity
    float_type sensitivity = 2 * clip_threshold;
    float_type noise_scale = sensitivity / this->privacy_budget_leaf_nodes;

    // Generate Laplace noise
    std::random_device device;
    std::mt19937 generator(device());
    std::exponential_distribution<double> distribution(1.0 / noise_scale);

    // Add symmetric Laplace noise (difference of two exponential distributions)
    double noise = distribution(generator) - distribution(generator);

    // Add noise to the clipped gradient
    value += noise;
}

void DifferentialPrivacy::add_noise_gradient(float_type &value, float_type min_gradient, float_type max_gradient) const {
    // Add noise without clipping
    const float_type sensitivity = max_gradient - min_gradient;
    const float_type noise_scale = sensitivity / this->privacy_budget_leaf_nodes;

    // Generate Laplace noise
    std::random_device device;
    // std::mt19937 generator(device());
    std::mt19937 generator(42);
    std::exponential_distribution<> distribution(1.0 / noise_scale);

    // Add symmetric Laplace noise (difference of two exponential distributions)
    const double noise = distribution(generator) - distribution(generator);

    // Add noise to the clipped gradient
    value += noise;
}
